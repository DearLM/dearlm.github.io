{"posts":[{"title":"Javascript switch 语句的替代方法","text":"本文扩展了 Todd Motto 关于用对象字面量替换 switch 语句的想法。这是过时、笨拙且冗长的 switch 语句的一种非常简洁美观的替代方法。在本文的最后，您将获得一个基于 Todd 解决方案的实用程序函数，该函数对开发人员更加友好，因此请坚持到最后！ 如果您对技术细节不感兴趣，只想了解实用程序函数，请向下滚动到最后一节（您需要的一切都在一个地方）。 那么 switch 语句有什么问题？虽然 switch 语句在某些情况下很有用，但许多人认为它不是 Javscript 最适合其用途的设计。它不如其他结构灵活、可读和可维护。 例如，对 switch 语句的主要批评之一是其贯穿行为。如果您忘记在 case 的末尾包含 break 语句，则控制权将贯穿到下一个 case ，从而导致意外行为，如下面的示例所示。这可能会使代码更容易出错且更难维护。 1234567891011121314switch (fruit) { case 'apple': console.log('Apple selected'); // Missing break statement, falls through to the next case case 'orange': console.log('Orange selected'); break; case 'banana': console.log('Banana selected'); break; default: console.log('Unknown fruit');} 在这个示例中，如果 fruit 为 'apple' ，则 &quot;Apple selected&quot; 和 &quot;Orange selected&quot; 都将被记录。 Object Literal 查找的替代方法与 switch 语句相比，Object Literal 更灵活、更具表现力。 以下是如何使用它们仅返回 string 值。 12345678910111213const getDate (unit) { var date = { 'year': '2024', 'month': 'January', 'day': '21', 'default': 'Default value' }; return (date[unit] || date['default']);}var month = getDate('month');console.log(month); // January 有时我们需要编写更复杂的代码，而仅返回 string 是不够的。我们可以进一步改进上述代码，在其中使用函数而不是字符串，以便我们可以包含更复杂的代码。 123456789101112131415161718192021222324const getDate (unit) { var date = { 'year': () =&gt; { // do more complicated stuff here // just returning a string in this case return '2024'; }, 'month': () =&gt; { return 'January'; }, 'day': () =&gt; { return '21'; }, 'default': () =&gt; { return 'Default value' } }; // we return the Object literal's function invoked return (date[unit] || date['default'])();}var month = getDate('month');console.log(month); // January 但是如果我们想要一个贯穿行为呢？我们可以轻松地使用对象字面量来实现这一点，它更具可读性、声明性和更不易出错。它还不会涉及添加或删除 break ，而这是我们正在寻找的。 1234567891011121314151617181920212223242526const getDayType (day) { const isWeekDay = () =&gt; { return 'Weekday'; } const isWeekEnd = () =&gt; { return 'Weekend'; } var days = { 'monday': isWeekDay, 'tuesday': isWeekDay, 'wednesday': isWeekDay, 'thursay': isWeekDay, 'friday': isWeekDay, 'saturday': isWeekEnd, 'sunday': isWeekEnd, 'default': () =&gt; { return 'Default value' } }; // we return the Object literal's function invoked return (days[day] || days['default'])();}var dayType = getDayType('sunday');console.log(dayType); // WeekEnd 将我们学到的东西变成一个实用函数既然我们已经学会了如何使用 Object Literal 而不是 switch ，那么让我们根据学到的知识构建一个实用函数，以进一步简化我们的生活。 我们称我们的函数为 switchCase 。它接收一个具有 2 个属性的对象： cases 和 defaultCase 。Cases 是将容纳我们案例的对象字面量，而 defaultCase 是…嗯，默认案例。 1234const switchCase = ({cases, defaultCase}) {} switchCase 是一个返回回调函数的高阶函数。回调函数接收 switch 表达式。 123456const switchCase = ({cases, defaultCase}) { return (expression) =&gt; { }} 现在，回调函数需要做的就是返回调用的对象字面量函数。 123456const switchCase = ({cases, defaultCase}) { return (expression) =&gt; { return (cases[expression] || defaultCase)(); }} 就是这样！现在让我们看一个如何使用它的示例。 12345678910111213141516let date = new Date()const today = switchCase({ cases: { year: () =&gt; date.getFullYear(), month: () =&gt; date.getMonth() + 1, day: () =&gt; date.getDate() }, defaultCase: () =&gt; date})today('year') // current yeartoday('month') // current monthtoday('day') // current daytoday('century') // default case - returns the current date Object 对于 typescript 用户，我们可以利用泛型来允许以后要调用该函数的用户指定他们希望对象字面量函数返回的类型。 1234567891011type SwitchCase&lt;T&gt; = { cases: {[key: string]: () =&gt; T}, defaultCase: () =&gt; T} const switchCase = &lt;T,&gt;({cases, defaultCase}: SwitchCase&lt;T&gt;) =&gt; { return (expression: string) =&gt; { return (cases[expression] || defaultCase)() }} 这就是我们如何使用它的方式。请注意，我们不必总是指定类型，因为 Typescript 会自动推断它，除非它是多个类型的联合，如下所示。 12345678910111213141516let date = new Date()const today = switchCase&lt;number | Date&gt;({ cases: { year: () =&gt; date.getFullYear(), month: () =&gt; date.getMonth() + 1, day: () =&gt; date.getDate() }, defaultCase: () =&gt; date})today('year') // current yeartoday('month') // current monthtoday('day') // current daytoday('century') // default case - returns the current date Object 您需要的一切都在一个地方# Javascript 版本 实用程序函数： 12const switchCase = ({cases, defaultCase}) =&gt; (expression) =&gt; (cases[expression] || defaultCase)() 用法： Tyepscript 版本 12345678910111213141516let date = new Date()const today = switchCase({ cases: { year: () =&gt; date.getFullYear(), month: () =&gt; date.getMonth() + 1, day: () =&gt; date.getDate() }, defaultCase: () =&gt; date})today('year') // current yeartoday('month') // current monthtoday('day') // current daytoday('century') // default case - returns the current date Object Tyepscript version 实用功能： 12const switchCase = &lt;T,&gt;({cases, defaultCase}: {cases: {[key: string]: () =&gt; T}, defaultCase: () =&gt; T}) =&gt; (expression: string) =&gt; (cases[expression] || defaultCase)() 用法： 12345678910111213141516let date = new Date()const today = switchCase&lt;number | Date&gt;({ cases: { year: () =&gt; date.getFullYear(), month: () =&gt; date.getMonth() + 1, day: () =&gt; date.getDate() }, defaultCase: () =&gt; date})today('year') // current yeartoday('month') // current monthtoday('day') // current daytoday('century') // default case - returns the current date Object 🌟更多精彩 点击👉这里~~","link":"/2024/01/22/Javascript%20switch%20%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%B3%95/"},{"title":"CSS 媒体查询","text":"简介：媒体查询提供了一种强大的方式，可根据设备类型、视口大小、屏幕像素密度或设备方向等因素调整我们的样式。 对于已经熟悉媒体查询的人来说，这篇文章可作为快速指南，揭示一些可能鲜为人知的巧妙技巧。 基本媒体查询：媒体查询使用 @media at 规则构建，包含媒体类型、零个或多个媒体功能，或媒体类型和媒体功能的组合。允许的媒体类型包括 all、print、screen 和 speech。如果未明确提及，则假定类型为“all”。 可以同时使用多种媒体类型，每种类型之间用逗号分隔： 在以下简单示例中，默认背景颜色为红色，但视口宽度为 650px 或更小的屏幕设备的背景颜色将变为蓝色： 指定媒体类型、媒体特性或同时指定二者的简单媒体查询示例： 利用多个媒体特性：为了满足媒体查询中的特定要求，您可以通过在多个媒体特性之间使用逻辑运算符“and”来指定多个媒体特性。使用“and”时，只有所有特性都评估为 true，查询才会匹配： 使用“或”逻辑运算符：通过定义多个以逗号分隔的查询，您可以引入逻辑“or”运算符。然后，媒体查询将转换为查询列表，如果任何逗号分隔的查询与条件匹配，则应用。 在下面的示例中，如果设备视口的最小宽度为 2rem 或最大纵横比为 4/1，则媒体查询成立： 使用“not”逻辑运算符：通过在查询的开头放置“not”，您可以实现相反的效果。当浏览器或设备无法满足特定条件时，这对于应用样式特别有用。一个示例场景是主要指针设备无法悬停在元素上时。 在使用“not”时，指定媒体类型至关重要。此外，需要注意的是，“not”适用于每个单独的查询，而不适用于以逗号分隔的整个查询列表。列表中的每个查询都独立地受“not”条件约束。 “only”逻辑运算符的独占使用：“only”逻辑运算符具有一个独特的特性——它对旧浏览器隐藏整个查询。简单来说，不理解“only”关键字的旧浏览器将忽略整个媒体查询。否则，“only”关键字本身对查询的行为没有影响。 🌟更多精彩 点击👉这里~~","link":"/2024/01/19/CSS%20%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/"},{"title":"检查和更新NPM包","text":"关于如何检查和更新 npm 包的快速概述。 TL;DR；用于检查和更新包的 npm 命令。 命令 说明 npm outdated 检查过时的软件包 npm update --save 更新软件包并保存到 package.json npm update --save-dev --save 更新开发软件包并保存到 package.json npm update -g 更新全局软件包 或者，您可以使用 npm-check-updates 检查和更新软件包。 命令 说明 npm install -g npm-check-updates 全局安装 npm-check-updates npx npm-check-updates 检查过时的软件包，无需安装 npm-check-updates ncu -u 更新软件包并保存到 package.json ncu -g -u 更新全局软件包 用于检查和更新软件包的 NPM 命令# npm outdated1npm outdated npm 文档：npm-outdated 此命令将检查注册表，以查看是否有任何（或特定）已安装的软件包当前已过时。 默认情况下，只显示根项目的直接依赖项和已配置工作区的直接依赖项。使用 --all 还可以查找所有过时的元依赖项。 npm 文档：npm-outdated npm update1npm update --save npm 文档：npm-update 更新软件包并保存到 package.json npm update –save-dev –save1npm update --save-dev --save npm 文档：npm-update –save-dev –save 更新开发软件包并保存到 package.json npm update -g1npm update -g npm 文档：npm-update -g 更新全局软件包 npm-check-updates 检查和更新软件包的命令npm-check-updates 将您的 package.json 依赖项升级到最新版本，忽略指定版本。 npm install -g npm-check-updates1npm install -g npm-check-updates npm 文档：npm-install -g npm-check-updates 全局安装 npm-check-updates npx npm-check-updates12npx npm-check-updates 检查过时的软件包，无需安装 npm-check-updates ncu -u1ncu -u 更新软件包并保存到 package.json ncu -g -u1ncu -g -u 更新全局软件包 🌟更多精彩 点击👉这里~~","link":"/2024/01/23/%E6%A3%80%E6%9F%A5%E5%92%8C%E6%9B%B4%E6%96%B0NPM%E5%8C%85/"},{"title":"Java中的排序-避坑","text":"关于java中排序的评论和文章在互联网上有很多，这篇文章将是我在我的开发者载体中看到的例子的总结。它不会涵盖所有的基础知识，但会尝试向您展示一些可能性，从我目前试图避免的可能性到我现在更喜欢使用的可能性。 对于所有测试目的，我们将使用Car类 1234567891011121314151617181920212223242526package com.developersmill.sorting.interfaceimpl;import java.util.Arrays;import java.util.Collections;import java.util.List;public final class Car{ private final int yearOfProduction; private final int horsePower; private final String brand; private final String model; public Car(int yearOfProduction, int horsePower, String brand, String model) { this.yearOfProduction = yearOfProduction; this.horsePower = horsePower; this.brand = brand; this.model = model; } @Override public String toString() { return &quot;Car{&quot; + &quot;yearOfProduction=&quot; + yearOfProduction + &quot;, horsePower=&quot; + horsePower + &quot;, brand='&quot; + brand + '\\'' + &quot;, model='&quot; + model + '\\'' + '}'; }} 这个示例列表： 123456789final List&lt;Car&gt; cars = Arrays.asList( new Car(1989, 60,&quot;Toyota&quot;, &quot;Yaris&quot;), new Car(2010, 90,&quot;Mazda&quot;, &quot;3&quot;), new Car(2004, 110,&quot;Toyota&quot;, &quot;Corolla&quot;), new Car(1999, 150,&quot;BMW&quot;, &quot;5&quot;), new Car(2010, 60,&quot;Renault&quot;, &quot;Clio&quot;), new Car(2016, 70,&quot;Renault&quot;, &quot;Twingo&quot;), new Car(2021, 190,&quot;Skoda&quot;, &quot;Superb&quot;)); 这几天怎么不实行分拣1.实现Comparable接口 第一个解决方案，也是我知道的最古老的一个，是实现一个接口Comparable，并在我们想要排序的类中提供compareTo方法的实现。我们会在课上讲汽车. 1234567public final class Car implements Comparable&lt;Car&gt; { .... @Override public int compareTo(Car car) { return yearOfProduction - car.yearOfProduction; }} 要测试我们的解决方案，只需在Collections类上调用sort方法 12Collections.sort(cars);cars.forEach(System.out::println); 结果是： 1234567Car{yearOfProduction=1989, horsePower=60, brand='Toyota', model='Yaris'}Car{yearOfProduction=1999, horsePower=150, brand='BMW', model='5'}Car{yearOfProduction=2004, horsePower=110, brand='Toyota', model='Corolla'}Car{yearOfProduction=2010, horsePower=90, brand='Mazda', model='3'}Car{yearOfProduction=2010, horsePower=60, brand='Renault', model='Clio'}Car{yearOfProduction=2016, horsePower=70, brand='Renault', model='Twingo'}Car{yearOfProduction=2021, horsePower=190, brand='Skoda', model='Superb'} 该解决方案具有两个主要问题： 它强制只基于一个特定字段进行比较，该字段不可更改。 它需要改变类 它修改输入对象-可变性 2.用新类提供比较器的不同实现 下一个解决方案是提供新的类来实现Comparator接口，每次我们想要改变数据的排序方式时。 例如，我们希望使用生产年份进行一次排序，使用马力进行一次排序。我们必须实现两个类： 123456789101112static class YearComparator implements Comparator&lt;Car&gt;{ @Override public int compare(Car o1, Car o2) { return o1.yearOfProduction - o2.yearOfProduction; }}static class HorsePowerComparator implements Comparator&lt;Car&gt;{ @Override public int compare(Car o1, Car o2) { return o1.horsePower - o2.horsePower; }} 每个类实现Comparator类并提供compare方法的实现。Car类接口Comparator不再需要了。现在测试我们的代码： 123Collections.sort(cars, new YearComparator()); // sort data using the year of production like in the first exampleCollections.sort(cars, new HorsePowerComparator()); // new way of sortingcars.forEach(System.out::println); 它也可以直接使用汽车列表本身： 1cars.sort(new HorsePowerComparator()); 结果是： 1234567Car{yearOfProduction=1989, horsePower=60, brand='Toyota', model='Yaris'}Car{yearOfProduction=2010, horsePower=60, brand='Renault', model='Clio'}Car{yearOfProduction=2016, horsePower=70, brand='Renault', model='Twingo'}Car{yearOfProduction=2010, horsePower=90, brand='Mazda', model='3'}Car{yearOfProduction=2004, horsePower=110, brand='Toyota', model='Corolla'}Car{yearOfProduction=1999, horsePower=150, brand='BMW', model='5'}Car{yearOfProduction=2021, horsePower=190, brand='Skoda', model='Superb'} 这个解决方案要好得多，但仍不完美。类不必实现接口，所以我们根本不必改变它。我们只需要为我们想要使用的每种情况提供Comparator类的实现。 3.使用Java流和可变列表 下一个示例显示，使用Java 8 API也可以很容易地完成排序。 我们的目标还是按照生产年份对汽车列表进行排序。为此，我们将使用带有Comparator参数的sorted方法。这可以通过几种方式来实现。下面的第一个例子展示了Comparator的内联实现，代码是一个lambda表达式。 123List&lt;Car&gt; sorted = new ArrayList&lt;&gt;();cars.stream().sorted((car1, car2) -&gt; car1.yearOfProduction - car2.yearOfProduction) .forEach(car -&gt; sorted.add(car)); 第二个例子展示了使用已经实现的类YearComparator： 123List&lt;Car&gt; sorted = new ArrayList&lt;&gt;();cars.stream().sorted(new YearComparator()) .forEach(car -&gt; sorted.add(car)); 这两个例子看起来比第1点和第2点中的例子更清晰，但其中有一个问题-可变性！如果我们决定切换到并发迭代，我们将被迫处理线程安全问题。 如何正确执行排序这一天1.使用Java 8流和collect方法 本文第3点中显示的所有示例都可以通过使用收集终端方法来修复。让我们改变最后一个使用’new YearComparator（）’比较器的例子： 123List&lt;Car&gt; sorted = cars.stream() .sorted(new YearComparator()) .collect(Collectors.toList()); 这将解决我们的并发修改问题，我们不再修改现有的对象。 2.使用Comparator的函数式风格 我们可以使用Java 8中引入的函数式编程风格来提供它的实现，而不是实现像YearComparator这样的小类。这可能看起来像这样： 1Comparator&lt;Car&gt; years = (car1, car2) -&gt; car1.yearOfProduction - car2.yearOfProduction; 使用此比较器的示例如下所示： 12List&lt;Car&gt; sorted = cars.stream().sorted(years) .collect(Collectors.toList()); 最终结果看起来像这样： 1234567Car{yearOfProduction=1989, horsePower=60, brand='Toyota', model='Yaris'}Car{yearOfProduction=1999, horsePower=150, brand='BMW', model='5'}Car{yearOfProduction=2004, horsePower=110, brand='Toyota', model='Corolla'}Car{yearOfProduction=2010, horsePower=60, brand='Renault', model='Clio'}Car{yearOfProduction=2010, horsePower=90, brand='Mazda', model='3'}Car{yearOfProduction=2016, horsePower=70, brand='Renault', model='Twingo'}Car{yearOfProduction=2021, horsePower=190, brand='Skoda', model='Superb'} 3.函数式风格与函数和比较 当Java 8引入时，Comparator接口充满了大量的静态方法。其中之一就是比较。它允许使用Function方法作为参数来使用其逻辑，以创建新的Comparator。最好是用一个例子来展示它。 假设我们有一个简单的Car POJO类，没有实现Comparable接口。我们想再次对年份属性进行排序。我们定义了我们的lambda，来说明我们想要执行排序的参数： 1Function&lt;Car, Integer&gt; year = car -&gt; car.yearOfProduction; 然后我们就这么简单地使用它： 123List&lt;Car&gt; sorted = cars.stream() .sorted(Comparator.comparing(year)) .collect(Collectors.toList()); 这将给我们给予我们想要的结果。我们甚至可以更进一步，定义第二个lambda来使用马力进行排序，并将这两个排序联合收割机结合在一起！ 1Function&lt;Car, Integer&gt; horsePower = car -&gt; car.horsePower; 首先按年份排序，然后按马力排序，看起来像这样： 1234List&lt;Car&gt; sorted = cars.stream() .sorted(Comparator.comparing(year) .thenComparing(horsePower)) .collect(Collectors.toList()); 结论 我们可以通过多种方式对数据进行排序。我自己发现使用Java 8 API有很多优点： 非可变数据-我们从不改变我们正在排序的数据，总是创建新的结果。 不强制改变我们正在排序的类（例如，实现Comparable接口）。 提供简单易读的lambda定义。 联合收割机几种分拣方式。 🌟更多精彩 点击👉这里~~","link":"/2024/01/24/Java%E4%B8%AD%E7%9A%84%E6%8E%92%E5%BA%8F-%E9%81%BF%E5%9D%91/"},{"title":"渐进式网络应用入门","text":"什么是渐进式网络应用 (PWA)？PWA 是一种渐进式网络应用程序，它结合了应用程序的功能和网络技术。 您可以说它们是使用网络技术构建的应用程序，但感觉和功能都像原生应用程序。 PWA 简介网络应用程序似乎变得有限，因为大多数人更喜欢构建移动应用程序，以便用户可以将它们保存在手机上，而不是构建网络应用程序，因为您必须不断访问浏览器。 然而，随着 PWA 的出现，这个问题已经得到解决，并且取得了很大的进展。 我所说的网络技术是指 HTML、CSS、JavaScript。 PWA 可以安装在您的主屏幕上，它们可以从您上次离开的地方离线工作，并提供与原生应用程序相当的体验和功能。 预计您的 PWA 会具有响应性。您不想构建在某些设备上没有响应性的网络应用。 虽然，您可以通过下载商店安装 PWA，但最简单且首选的方式是通过上述浏览器安装。PWA 由于它提供了特定于平台的用户体验， 它们位于您的主屏幕上，易于访问且易于查找。 它们可以离线访问 PWA 与网站的区别网站更像是一个访问区域，而不是一个所有权区域。你不能说我有一个网站，但你可以说我有一个应用程序。 PWA 即使是一个转换后的网站，也能给你带来这种体验。 PWA 可以从平台的应用商店安装，也可以直接从网络安装。 PWA 可以像特定于平台的应用一样安装，并且可以自定义安装过程。 PWA 一旦安装，就会在设备上获得一个应用图标，与特定于平台的应用并排显示。 一旦安装，PWA 可以作为一个独立的应用启动，而不是浏览器中的网站。 PWA 可以后台运行，也可以离线运行。这与普通网站不同，普通网站只有在页面在浏览器中加载时才处于活动状态。 PWA 可以后台更新内容，响应来自服务器的推送通知，并在设备没有网络连接时工作。 使用操作系统通知系统显示通知 PWA 可以集成到设备中，注册为共享目标和源并访问设备功能。 PWA 可以使用整个屏幕，而无需在浏览器 UI 中运行。 如何构建 PWA渐进式网络应用程序由以下部分组成： Manifest.json 服务工作者 离线 HTML 页面（非强制性，在没有互联网时使用） 应用程序外壳结构 Manifest.json它还用于构建 Chrome 浏览器扩展程序。它有助于将应用程序显示为主屏幕上的应用。 网络应用清单是一个 JSON 文件，它定义了如何将 PWA 视为已安装的应用程序，包括操作系统中的外观和基本行为。 它告诉浏览器您希望您的网络内容如何在操作系统中显示为应用程序。清单可以包括基本信息，例如应用程序的名称、图标和主题颜色，高级首选项，例如所需的方向和应用程序快捷方式；以及目录元数据，例如屏幕截图。manifest.json 是使用网络扩展 API 的每个扩展都必须包含的唯一文件。 服务工作者它有助于缓存。保存数据以便以后使用。 它们可以提高 PWA 中网页的性能和功能，因为它们通过缓存 HTML、CSS、JavaScript、图像和字体等静态资源来减少加载时间和带宽使用量。 它们提供离线功能、处理通知或执行繁重的计算，并且可以控制网络请求、修改它们、提供从缓存中检索的自定义响应或完全合成响应。 快速加载、推送通知、离线访问 推出渐进式网络应用的公司已经看到了推出渐进式网络应用的公司已经看到了令人印象深刻的结果。例如，Twitter 看到每次会话的页面增加了 65%，推文增加了 75%，跳出率降低了 20%，同时将应用的体积减少了 97% 以上。切换到 PWA 后，日经新闻的有机流量增加了 2.3 倍，订阅量增加了 58%，每日活跃用户增加了 49%。Hulu 用渐进式网络应用取代了其特定于平台的桌面体验，返回访问量增加了 27%。 PWA 和 Web 应用之间的差异 安装： 无论是在台式机还是移动设备上，您都可以安装 PWA。但是，网络应用程序旨在在网络浏览器中运行，无法安装在设备上。因此，用户最好考虑这一点。 类应用体验： 虽然渐进式网络应用使用与网络应用相同的技术，如 HTML、CSS、JavaScript 等。但它提供的是原生应用的用户体验。此外，与网络应用不同，PWA 可以使用大多数设备功能，如推送通知，而不管使用的网络浏览器是什么。它提供了一种如此集成和无缝的体验，以至于区分 PWA 和原生应用变得非常困难。 易于访问： PWA 很轻量，因为它们占用的空间非常小，与原生应用相比，只有几 KB。您无法安装网络应用，但可以通过网络浏览器访问它。安装 PWA 后，用户可以轻松地从主屏幕或应用程序抽屉中访问它，应用程序图标将像原生应用程序一样显示在那里。此外，可以共享 PWA 以允许其他人安装该应用程序。因此，它减少了安装应用程序的步骤。 更快的用户体验： 渐进式网络应用可以缓存数据，以便在整个应用程序完全加载之前为用户提供图像、文本和其他内容。它减少了用户的等待时间，从而提高了留存率和用户参与度。它为您的业务增加了价值。 更多用户参与度： 渐进式网络应用程序的一项主要优势是，它们可以使用推送通知和许多其他设备功能，使企业能够提高用户参与度。通过使用推送通知，企业可以向用户发送有关其优惠、交易和服务的信息，以让他们持续参与您的品牌。 实时数据访问： 渐进式网络应用程序的另一个优势是，它们始终保持最新。这是因为当出现某些更改时，这些应用程序会自行更新。网络应用程序本身就是一个网站，因此也会自动更新。然而，作为网络应用程序的高级版本，渐进式网络应用程序具有优势。 原生应用程序（移动应用程序）和渐进式网络应用程序之间的差异 开发成本： 渐进式网络应用程序比原生应用程序更便宜，开发时间也相对较短。 用户体验： 原生应用程序提供比渐进式网络应用程序更精致、更完善的用户体验。原生应用程序旨在利用设备的硬件和软件功能，为用户提供无缝且响应迅速的体验。 可访问性： 渐进式网络应用程序比原生应用程序更易于访问，因为它们可以在任何具有网络浏览器的设备上访问。原生应用程序仅限于特定平台。 维护和更新： 维护和更新 PWA 通常比原生应用更容易。使用 PWA，可以在服务器端进行更新，用户无需下载和安装任何内容即可访问该应用的最新版本 开发渐进式网络应用的好处 开发成本低： 开发 PWA 的成本远低于任何原生应用或网络应用。 可发现 PWA 可与网络浏览器配合使用，并且可以在搜索引擎中发现它们，这为您优化搜索引擎提供了机会。您可以利用 SEO 来提高其排名并吸引更多用户以促进销售 跨平台功能 PWA 既跨平台又兼容跨浏览器，因为它们可以与每种设备和网络浏览器配合使用。 *离线使用 * 由于缓存，PWA 可以将数据存储在设备上，使用户即使没有互联网连接也可以访问内容。因此，PWA 可以离线工作。 安全性 PWA 安全、快速、用户友好且功能丰富的网络解决方案，可最大限度地提高您的收入。 它如何改善电子商务购物体验 通过社交账户登录 推送通知提醒 简化支付处理 无网络购物 跟踪独特分析 🌟更多精彩 点击👉这里~~","link":"/2024/01/19/%E6%B8%90%E8%BF%9B%E5%BC%8F%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%85%A5%E9%97%A8/"},{"title":"面向初学者的 JavaScript 中的 Promise","text":"在 javascript 中使用异步代码时，有时需要等待代码返回数据，然后再进一步处理数据。例如：读取文件需要一些时间，或者从服务器获取数据可能需要时间，因为这是异步任务，所以它被委托了。 然而，在我们的代码中处理和做任何进一步的事情之前，我们需要这些数据。 这就是 promises 可以非常有帮助的地方。 什么是 Promise？ 在引入 promises 之前，异步操作的管理是使用回调函数完成的。 回调函数是作为参数传递给另一个函数的函数，并在异步操作完成后执行。 然而，随着程序变得越来越复杂，管理回调函数变得具有挑战性，导致了人们常说的“回调地狱”或“厄运金字塔”。 这种情况是嵌套回调使代码难以阅读和维护。 引入 promises 是为了解决这些问题，并提供一种更好/更干净的方式来处理异步操作。 简而言之，如果异步任务成功完成，它会返回一个包含数据的结果对象，如果任务失败，它会返回一个包含错误的拒绝对象。Promise 确保一旦操作完成，您可以根据操作的完成或失败执行任何您想要的操作。 Promise 的状态Promise 有三种状态： pending：Promise 正在等待，既未解决也未拒绝 resolved：一旦 Promise 解决，它会将数据返回给 `then()` 方法 rejected：一旦 Promise 被拒绝，错误将返回给 `catch()` Promise 的基本示例用法： 12345678910111213// Creating a promise let myPromise = new Promise((resolve, reject) =&gt; { // Simulating async operation using setTimeout setTimeout(() =&gt; { let success = true; if (success) { resolve(&quot;Data fetched successfully&quot;); } else { reject(&quot;Error fetching data&quot;); } }, 2000);}); 这段代码表示创建了一个新的 Promise，它执行异步操作（例如 setTimeout() ），一旦完成，它要么解决 Promise（表示成功），要么因错误而被拒绝。 创建 Promise 后，您可以使用该 Promise。 1234567891011// Consuming the promisemyPromise.then((result) =&gt; { console.log(result);}).catch((error) =&gt; { console.error(error);})//default one, gets executed no matter resolve or reject.finally(() =&gt; {}); 如果 Promise 已解决，则将其返回给该 Promise 的 .then() 方法，如果 Promise 被拒绝，则将其返回给 .catch() 方法。 在两种情况下，您都可以在承诺完成后执行任务。 如何处理承诺返回的数据？这可以通过 then() 和 catch() 的链式调用来完成 一旦从 resolve 返回数据，您就可以在 then() 方法中获取该数据，然后将其返回到新的 then 链中，然后您可以使用该数据，并且错误由 catch() 方法捕获。 1234567891011121314151617181920const promise = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; {} const error = false; console.log(&quot;Async task completed!&quot;); //data returned with resolve if(error === false) resolve([1,2,3]);, 1000);});//handling data with chaining of then() and catch()promise.then((data) =&gt; { return response;}).then((data) =&gt; { console.log(data.splice(0, 1));}).catch((err) =&gt; { console.log(err);}) 🌟更多精彩 点击👉这里~~","link":"/2024/01/22/%E9%9D%A2%E5%90%91%E5%88%9D%E5%AD%A6%E8%80%85%E7%9A%84JavaScript%E4%B8%AD%E7%9A%84Promise/"},{"title":"JavaScript 中的递归","text":"您是否曾经发现自己需要在 JavaScript 中循环遍历一个复杂的多维对象，却不知道如何操作？如果是这样，您应该考虑使用搜索引擎作为查找解决方案的强大工具。但是，既然您已经在这里，如果您继续阅读，您就会找到解决此问题的优雅解决方案。 让我们以以下树为例开始。 1234567891011121314151617181920212223const mySuperComplexTree = { name: &quot;root&quot;, children: [ { name: &quot;child-1&quot;, children: [ { name: &quot;child-1-1&quot;, children: [ { name: &quot;child-1-1-1&quot;, children: [] } ] } ] }, { name: &quot;child-2&quot;, children: [] } ]}; 问题：您必须将每个节点名称（包括根节点）打印到控制台。 当我们第一次遇到这类问题时，我们倾向于被邓宁-克鲁格效应所误导，并认为可以用一个简单的 for 循环来解决。简短的回答是肯定的……但同样，那并不总是最好的方法。 让我们看看当我们遵循这种方法时会发生什么： 1234567891011121314151617console.log(mySuperComplexTree.name);for (const node of mySuperComplexTree.children) { console.log(node.name); for (const node2 of node.children) { console.log(node2.name); for (const node3 of node2.children) { console.log(node3.name); } }}// Output:// root// child-1// child-1-1// child-1-1-1// child-2 GIF 正如您可能看到的，即使它起作用了，此解决方案也存在几个问题： 首先，它不容易阅读。没有人想在他们的代码中看到一堆嵌套循环，而且你是团队成员，对吧？ 如果这棵树在运行时需要发生变化，会发生什么？当前的实现不是动态的，因此您必须修改代码并手动添加更多嵌套循环。这会使代码更难阅读且更难维护。 **这就是递归派上用场的地方。** 那么，递归函数到底是什么？GIF 它是一个在执行期间调用自身的函数。此特性允许它用于解决可以分解为与整体问题相同的更小、更简单的子问题的问题。 一个简单的方法是使用递归来实现倒计时功能。让我们看看。 123456function countDownFrom(n) { if (n &lt; 0) return; console.log(n); countDownFrom(n - 1);}countDownFrom(10); 在此示例中， countDownFrom 函数打印一个数字，然后使用您传递的数字（减一）调用自身（递归），重复此过程，直到达到基本情况（在本例中，当 n 小于 0 时）。 正如你所见，它基本上是一个循环，但更简单、更优雅。 让我们回到我们的树对象。我们的初始问题是，我们需要打印树的所有节点名称，我们将使用递归来解决它，因为我们注意到我们的树具有一个常量结构，其中每个节点都有一个 name 属性（我们要打印的字符串）和一个 children 属性（一个节点数组）。 因此，我们的函数需要接收一个节点并打印其名称，然后由于所有子节点都是相似的，我们可以循环一次子节点并仅调用传递子节点的相同函数。这将接收一个母鹿，打印其名称并重复该过程。 123456789101112131415function printNodeNames(tree) { console.log(tree.name); for (const node of tree.children) { printNodeNames(node); }}printNodeNames(mySuperComplexTree);// Output:// root// child-1// child-1-1// child-1-1-1// child-2 正如您所见， printNodeNames 函数解决了我们的初始问题。 它首先打印当前节点的名称（作为参数传递）。然后，它循环遍历当前节点的子节点数组，并针对每个子节点调用自身（再次递归），将子节点作为新参数传递。此过程一直持续到它打印树中的所有节点名称。这正是我们所说的我们需要的东西。 此函数演示了遍历树结构的常见模式：处理当前节点（在本例中，打印其名称），然后递归处理所有子节点。 这种技术被称为深度优先遍历，因为它在回溯之前尽可能深入树中。 为什么使用递归如果您出于某种原因尚未被说服使用递归函数，我将为您提供四个递归函数如此有用的原因。 简单性：递归通常比其迭代对应项（for、while 等）更容易理解。它们可以将复杂的任务变成更简单的任务。 问题解决：有些问题本质上是递归的，例如树遍历、河内塔等。对于此类问题，使用递归函数更容易。 分而治之：递归函数允许您将较大的问题分解为较小、更易于管理的子问题。这是许多高效算法（如归并排序和快速排序）的基础。 更少的代码：递归函数可以减少代码量。好的，更短的代码并不一定意味着更好，但它可以使代码更具可读性。 总之，递归不仅是某些问题的优雅解决方案，而且是将任务分解为更小任务（例如遍历树或对列表进行排序）的强大且有用的工具。 它们的关键组件是基本情况（函数停止调用自身的情况）和递归情况（函数调用自身的部分）。 但是，与迭代解决方案相比，它们可能更难理解和调试，并且如果未仔细实现，还可能导致堆栈溢出等性能问题。因此，谨慎使用递归并确保始终可以访问基本情况非常重要。 🌟更多精彩 点击👉这里~~","link":"/2024/01/25/JavaScript%E4%B8%AD%E7%9A%84%E9%80%92%E5%BD%92/"}],"tags":[{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"designpatterns","slug":"designpatterns","link":"/tags/designpatterns/"},{"name":"coding","slug":"coding","link":"/tags/coding/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"初学者","slug":"初学者","link":"/tags/%E5%88%9D%E5%AD%A6%E8%80%85/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"webdev","slug":"webdev","link":"/tags/webdev/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"sorting","slug":"sorting","link":"/tags/sorting/"},{"name":"comparator","slug":"comparator","link":"/tags/comparator/"},{"name":"cleancode","slug":"cleancode","link":"/tags/cleancode/"},{"name":"pwa","slug":"pwa","link":"/tags/pwa/"},{"name":"pwabuilder","slug":"pwabuilder","link":"/tags/pwabuilder/"},{"name":"promises","slug":"promises","link":"/tags/promises/"},{"name":"beginners","slug":"beginners","link":"/tags/beginners/"}],"categories":[{"name":"csdn","slug":"csdn","link":"/categories/csdn/"},{"name":"转载","slug":"转载","link":"/categories/%E8%BD%AC%E8%BD%BD/"}],"pages":[]}