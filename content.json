{"posts":[{"title":"渐进式网络应用入门","text":"什么是渐进式网络应用 (PWA)？PWA 是一种渐进式网络应用程序，它结合了应用程序的功能和网络技术。 您可以说它们是使用网络技术构建的应用程序，但感觉和功能都像原生应用程序。 PWA 简介网络应用程序似乎变得有限，因为大多数人更喜欢构建移动应用程序，以便用户可以将它们保存在手机上，而不是构建网络应用程序，因为您必须不断访问浏览器。 然而，随着 PWA 的出现，这个问题已经得到解决，并且取得了很大的进展。 我所说的网络技术是指 HTML、CSS、JavaScript。 PWA 可以安装在您的主屏幕上，它们可以从您上次离开的地方离线工作，并提供与原生应用程序相当的体验和功能。 预计您的 PWA 会具有响应性。您不想构建在某些设备上没有响应性的网络应用。 虽然，您可以通过下载商店安装 PWA，但最简单且首选的方式是通过上述浏览器安装。PWA 由于它提供了特定于平台的用户体验， 它们位于您的主屏幕上，易于访问且易于查找。 它们可以离线访问 PWA 与网站的区别网站更像是一个访问区域，而不是一个所有权区域。你不能说我有一个网站，但你可以说我有一个应用程序。 PWA 即使是一个转换后的网站，也能给你带来这种体验。 PWA 可以从平台的应用商店安装，也可以直接从网络安装。 PWA 可以像特定于平台的应用一样安装，并且可以自定义安装过程。 PWA 一旦安装，就会在设备上获得一个应用图标，与特定于平台的应用并排显示。 一旦安装，PWA 可以作为一个独立的应用启动，而不是浏览器中的网站。 PWA 可以后台运行，也可以离线运行。这与普通网站不同，普通网站只有在页面在浏览器中加载时才处于活动状态。 PWA 可以后台更新内容，响应来自服务器的推送通知，并在设备没有网络连接时工作。 使用操作系统通知系统显示通知 PWA 可以集成到设备中，注册为共享目标和源并访问设备功能。 PWA 可以使用整个屏幕，而无需在浏览器 UI 中运行。 如何构建 PWA渐进式网络应用程序由以下部分组成： Manifest.json 服务工作者 离线 HTML 页面（非强制性，在没有互联网时使用） 应用程序外壳结构 Manifest.json它还用于构建 Chrome 浏览器扩展程序。它有助于将应用程序显示为主屏幕上的应用。 网络应用清单是一个 JSON 文件，它定义了如何将 PWA 视为已安装的应用程序，包括操作系统中的外观和基本行为。 它告诉浏览器您希望您的网络内容如何在操作系统中显示为应用程序。清单可以包括基本信息，例如应用程序的名称、图标和主题颜色，高级首选项，例如所需的方向和应用程序快捷方式；以及目录元数据，例如屏幕截图。manifest.json 是使用网络扩展 API 的每个扩展都必须包含的唯一文件。 服务工作者它有助于缓存。保存数据以便以后使用。 它们可以提高 PWA 中网页的性能和功能，因为它们通过缓存 HTML、CSS、JavaScript、图像和字体等静态资源来减少加载时间和带宽使用量。 它们提供离线功能、处理通知或执行繁重的计算，并且可以控制网络请求、修改它们、提供从缓存中检索的自定义响应或完全合成响应。 快速加载、推送通知、离线访问 推出渐进式网络应用的公司已经看到了推出渐进式网络应用的公司已经看到了令人印象深刻的结果。例如，Twitter 看到每次会话的页面增加了 65%，推文增加了 75%，跳出率降低了 20%，同时将应用的体积减少了 97% 以上。切换到 PWA 后，日经新闻的有机流量增加了 2.3 倍，订阅量增加了 58%，每日活跃用户增加了 49%。Hulu 用渐进式网络应用取代了其特定于平台的桌面体验，返回访问量增加了 27%。 PWA 和 Web 应用之间的差异 安装： 无论是在台式机还是移动设备上，您都可以安装 PWA。但是，网络应用程序旨在在网络浏览器中运行，无法安装在设备上。因此，用户最好考虑这一点。 类应用体验： 虽然渐进式网络应用使用与网络应用相同的技术，如 HTML、CSS、JavaScript 等。但它提供的是原生应用的用户体验。此外，与网络应用不同，PWA 可以使用大多数设备功能，如推送通知，而不管使用的网络浏览器是什么。它提供了一种如此集成和无缝的体验，以至于区分 PWA 和原生应用变得非常困难。 易于访问： PWA 很轻量，因为它们占用的空间非常小，与原生应用相比，只有几 KB。您无法安装网络应用，但可以通过网络浏览器访问它。安装 PWA 后，用户可以轻松地从主屏幕或应用程序抽屉中访问它，应用程序图标将像原生应用程序一样显示在那里。此外，可以共享 PWA 以允许其他人安装该应用程序。因此，它减少了安装应用程序的步骤。 更快的用户体验： 渐进式网络应用可以缓存数据，以便在整个应用程序完全加载之前为用户提供图像、文本和其他内容。它减少了用户的等待时间，从而提高了留存率和用户参与度。它为您的业务增加了价值。 更多用户参与度： 渐进式网络应用程序的一项主要优势是，它们可以使用推送通知和许多其他设备功能，使企业能够提高用户参与度。通过使用推送通知，企业可以向用户发送有关其优惠、交易和服务的信息，以让他们持续参与您的品牌。 实时数据访问： 渐进式网络应用程序的另一个优势是，它们始终保持最新。这是因为当出现某些更改时，这些应用程序会自行更新。网络应用程序本身就是一个网站，因此也会自动更新。然而，作为网络应用程序的高级版本，渐进式网络应用程序具有优势。 原生应用程序（移动应用程序）和渐进式网络应用程序之间的差异 开发成本： 渐进式网络应用程序比原生应用程序更便宜，开发时间也相对较短。 用户体验： 原生应用程序提供比渐进式网络应用程序更精致、更完善的用户体验。原生应用程序旨在利用设备的硬件和软件功能，为用户提供无缝且响应迅速的体验。 可访问性： 渐进式网络应用程序比原生应用程序更易于访问，因为它们可以在任何具有网络浏览器的设备上访问。原生应用程序仅限于特定平台。 维护和更新： 维护和更新 PWA 通常比原生应用更容易。使用 PWA，可以在服务器端进行更新，用户无需下载和安装任何内容即可访问该应用的最新版本 开发渐进式网络应用的好处 开发成本低： 开发 PWA 的成本远低于任何原生应用或网络应用。 可发现 PWA 可与网络浏览器配合使用，并且可以在搜索引擎中发现它们，这为您优化搜索引擎提供了机会。您可以利用 SEO 来提高其排名并吸引更多用户以促进销售 跨平台功能 PWA 既跨平台又兼容跨浏览器，因为它们可以与每种设备和网络浏览器配合使用。 *离线使用 * 由于缓存，PWA 可以将数据存储在设备上，使用户即使没有互联网连接也可以访问内容。因此，PWA 可以离线工作。 安全性 PWA 安全、快速、用户友好且功能丰富的网络解决方案，可最大限度地提高您的收入。 它如何改善电子商务购物体验 通过社交账户登录 推送通知提醒 简化支付处理 无网络购物 跟踪独特分析","link":"/lmblog/2024/01/19/%E6%B8%90%E8%BF%9B%E5%BC%8F%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%85%A5%E9%97%A8/"},{"title":"面向初学者的 JavaScript 中的 Promise","text":"在 javascript 中使用异步代码时，有时需要等待代码返回数据，然后再进一步处理数据。例如：读取文件需要一些时间，或者从服务器获取数据可能需要时间，因为这是异步任务，所以它被委托了。 然而，在我们的代码中处理和做任何进一步的事情之前，我们需要这些数据。 这就是 promises 可以非常有帮助的地方。 什么是 Promise？ 在引入 promises 之前，异步操作的管理是使用回调函数完成的。 回调函数是作为参数传递给另一个函数的函数，并在异步操作完成后执行。 然而，随着程序变得越来越复杂，管理回调函数变得具有挑战性，导致了人们常说的“回调地狱”或“厄运金字塔”。 这种情况是嵌套回调使代码难以阅读和维护。 引入 promises 是为了解决这些问题，并提供一种更好/更干净的方式来处理异步操作。 简而言之，如果异步任务成功完成，它会返回一个包含数据的结果对象，如果任务失败，它会返回一个包含错误的拒绝对象。Promise 确保一旦操作完成，您可以根据操作的完成或失败执行任何您想要的操作。 Promise 的状态Promise 有三种状态： pending：Promise 正在等待，既未解决也未拒绝 resolved：一旦 Promise 解决，它会将数据返回给 `then()` 方法 rejected：一旦 Promise 被拒绝，错误将返回给 `catch()` Promise 的基本示例用法： 12345678910111213// Creating a promise let myPromise = new Promise((resolve, reject) =&gt; { // Simulating async operation using setTimeout setTimeout(() =&gt; { let success = true; if (success) { resolve(&quot;Data fetched successfully&quot;); } else { reject(&quot;Error fetching data&quot;); } }, 2000);}); 这段代码表示创建了一个新的 Promise，它执行异步操作（例如 setTimeout() ），一旦完成，它要么解决 Promise（表示成功），要么因错误而被拒绝。 创建 Promise 后，您可以使用该 Promise。 1234567891011// Consuming the promisemyPromise.then((result) =&gt; { console.log(result);}).catch((error) =&gt; { console.error(error);})//default one, gets executed no matter resolve or reject.finally(() =&gt; {}); 如果 Promise 已解决，则将其返回给该 Promise 的 .then() 方法，如果 Promise 被拒绝，则将其返回给 .catch() 方法。 在两种情况下，您都可以在承诺完成后执行任务。 如何处理承诺返回的数据？这可以通过 then() 和 catch() 的链式调用来完成 一旦从 resolve 返回数据，您就可以在 then() 方法中获取该数据，然后将其返回到新的 then 链中，然后您可以使用该数据，并且错误由 catch() 方法捕获。 1234567891011121314151617181920const promise = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; {} const error = false; console.log(&quot;Async task completed!&quot;); //data returned with resolve if(error === false) resolve([1,2,3]);, 1000);});//handling data with chaining of then() and catch()promise.then((data) =&gt; { return response;}).then((data) =&gt; { console.log(data.splice(0, 1));}).catch((err) =&gt; { console.log(err);})","link":"/lmblog/2024/01/22/%E9%9D%A2%E5%90%91%E5%88%9D%E5%AD%A6%E8%80%85%E7%9A%84JavaScript%E4%B8%AD%E7%9A%84Promise/"},{"title":"CSS 媒体查询","text":"简介：媒体查询提供了一种强大的方式，可根据设备类型、视口大小、屏幕像素密度或设备方向等因素调整我们的样式。 对于已经熟悉媒体查询的人来说，这篇文章可作为快速指南，揭示一些可能鲜为人知的巧妙技巧。 基本媒体查询：媒体查询使用 @media at 规则构建，包含媒体类型、零个或多个媒体功能，或媒体类型和媒体功能的组合。允许的媒体类型包括 all、print、screen 和 speech。如果未明确提及，则假定类型为“all”。 可以同时使用多种媒体类型，每种类型之间用逗号分隔： 在以下简单示例中，默认背景颜色为红色，但视口宽度为 650px 或更小的屏幕设备的背景颜色将变为蓝色： 指定媒体类型、媒体特性或同时指定二者的简单媒体查询示例： 利用多个媒体特性：为了满足媒体查询中的特定要求，您可以通过在多个媒体特性之间使用逻辑运算符“and”来指定多个媒体特性。使用“and”时，只有所有特性都评估为 true，查询才会匹配： 使用“或”逻辑运算符：通过定义多个以逗号分隔的查询，您可以引入逻辑“or”运算符。然后，媒体查询将转换为查询列表，如果任何逗号分隔的查询与条件匹配，则应用。 在下面的示例中，如果设备视口的最小宽度为 2rem 或最大纵横比为 4/1，则媒体查询成立： 使用“not”逻辑运算符：通过在查询的开头放置“not”，您可以实现相反的效果。当浏览器或设备无法满足特定条件时，这对于应用样式特别有用。一个示例场景是主要指针设备无法悬停在元素上时。 在使用“not”时，指定媒体类型至关重要。此外，需要注意的是，“not”适用于每个单独的查询，而不适用于以逗号分隔的整个查询列表。列表中的每个查询都独立地受“not”条件约束。 “only”逻辑运算符的独占使用：“only”逻辑运算符具有一个独特的特性——它对旧浏览器隐藏整个查询。简单来说，不理解“only”关键字的旧浏览器将忽略整个媒体查询。否则，“only”关键字本身对查询的行为没有影响。 🌟更多精彩 点击👉这里~~","link":"/lmblog/2024/01/19/CSS%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/"},{"title":"Javascript switch 语句的替代方法","text":"本文扩展了 Todd Motto 关于用对象字面量替换 switch 语句的想法。这是过时、笨拙且冗长的 switch 语句的一种非常简洁美观的替代方法。在本文的最后，您将获得一个基于 Todd 解决方案的实用程序函数，该函数对开发人员更加友好，因此请坚持到最后！ 如果您对技术细节不感兴趣，只想了解实用程序函数，请向下滚动到最后一节（您需要的一切都在一个地方）。 那么 switch 语句有什么问题？虽然 switch 语句在某些情况下很有用，但许多人认为它不是 Javscript 最适合其用途的设计。它不如其他结构灵活、可读和可维护。 例如，对 switch 语句的主要批评之一是其贯穿行为。如果您忘记在 case 的末尾包含 break 语句，则控制权将贯穿到下一个 case ，从而导致意外行为，如下面的示例所示。这可能会使代码更容易出错且更难维护。 1234567891011121314switch (fruit) { case 'apple': console.log('Apple selected'); // Missing break statement, falls through to the next case case 'orange': console.log('Orange selected'); break; case 'banana': console.log('Banana selected'); break; default: console.log('Unknown fruit');} 在这个示例中，如果 fruit 为 'apple' ，则 &quot;Apple selected&quot; 和 &quot;Orange selected&quot; 都将被记录。 Object Literal 查找的替代方法与 switch 语句相比，Object Literal 更灵活、更具表现力。 以下是如何使用它们仅返回 string 值。 12345678910111213const getDate (unit) { var date = { 'year': '2024', 'month': 'January', 'day': '21', 'default': 'Default value' }; return (date[unit] || date['default']);}var month = getDate('month');console.log(month); // January 有时我们需要编写更复杂的代码，而仅返回 string 是不够的。我们可以进一步改进上述代码，在其中使用函数而不是字符串，以便我们可以包含更复杂的代码。 123456789101112131415161718192021222324const getDate (unit) { var date = { 'year': () =&gt; { // do more complicated stuff here // just returning a string in this case return '2024'; }, 'month': () =&gt; { return 'January'; }, 'day': () =&gt; { return '21'; }, 'default': () =&gt; { return 'Default value' } }; // we return the Object literal's function invoked return (date[unit] || date['default'])();}var month = getDate('month');console.log(month); // January 但是如果我们想要一个贯穿行为呢？我们可以轻松地使用对象字面量来实现这一点，它更具可读性、声明性和更不易出错。它还不会涉及添加或删除 break ，而这是我们正在寻找的。 1234567891011121314151617181920212223242526const getDayType (day) { const isWeekDay = () =&gt; { return 'Weekday'; } const isWeekEnd = () =&gt; { return 'Weekend'; } var days = { 'monday': isWeekDay, 'tuesday': isWeekDay, 'wednesday': isWeekDay, 'thursay': isWeekDay, 'friday': isWeekDay, 'saturday': isWeekEnd, 'sunday': isWeekEnd, 'default': () =&gt; { return 'Default value' } }; // we return the Object literal's function invoked return (days[day] || days['default'])();}var dayType = getDayType('sunday');console.log(dayType); // WeekEnd 将我们学到的东西变成一个实用函数既然我们已经学会了如何使用 Object Literal 而不是 switch ，那么让我们根据学到的知识构建一个实用函数，以进一步简化我们的生活。 我们称我们的函数为 switchCase 。它接收一个具有 2 个属性的对象： cases 和 defaultCase 。Cases 是将容纳我们案例的对象字面量，而 defaultCase 是…嗯，默认案例。 1234const switchCase = ({cases, defaultCase}) {} switchCase 是一个返回回调函数的高阶函数。回调函数接收 switch 表达式。 123456const switchCase = ({cases, defaultCase}) { return (expression) =&gt; { }} 现在，回调函数需要做的就是返回调用的对象字面量函数。 123456const switchCase = ({cases, defaultCase}) { return (expression) =&gt; { return (cases[expression] || defaultCase)(); }} 就是这样！现在让我们看一个如何使用它的示例。 12345678910111213141516let date = new Date()const today = switchCase({ cases: { year: () =&gt; date.getFullYear(), month: () =&gt; date.getMonth() + 1, day: () =&gt; date.getDate() }, defaultCase: () =&gt; date})today('year') // current yeartoday('month') // current monthtoday('day') // current daytoday('century') // default case - returns the current date Object 对于 typescript 用户，我们可以利用泛型来允许以后要调用该函数的用户指定他们希望对象字面量函数返回的类型。 1234567891011type SwitchCase&lt;T&gt; = { cases: {[key: string]: () =&gt; T}, defaultCase: () =&gt; T} const switchCase = &lt;T,&gt;({cases, defaultCase}: SwitchCase&lt;T&gt;) =&gt; { return (expression: string) =&gt; { return (cases[expression] || defaultCase)() }} 这就是我们如何使用它的方式。请注意，我们不必总是指定类型，因为 Typescript 会自动推断它，除非它是多个类型的联合，如下所示。 12345678910111213141516let date = new Date()const today = switchCase&lt;number | Date&gt;({ cases: { year: () =&gt; date.getFullYear(), month: () =&gt; date.getMonth() + 1, day: () =&gt; date.getDate() }, defaultCase: () =&gt; date})today('year') // current yeartoday('month') // current monthtoday('day') // current daytoday('century') // default case - returns the current date Object 您需要的一切都在一个地方# Javascript 版本 实用程序函数： 12const switchCase = ({cases, defaultCase}) =&gt; (expression) =&gt; (cases[expression] || defaultCase)() 用法： Tyepscript 版本 12345678910111213141516let date = new Date()const today = switchCase({ cases: { year: () =&gt; date.getFullYear(), month: () =&gt; date.getMonth() + 1, day: () =&gt; date.getDate() }, defaultCase: () =&gt; date})today('year') // current yeartoday('month') // current monthtoday('day') // current daytoday('century') // default case - returns the current date Object Tyepscript version 实用功能： 12const switchCase = &lt;T,&gt;({cases, defaultCase}: {cases: {[key: string]: () =&gt; T}, defaultCase: () =&gt; T}) =&gt; (expression: string) =&gt; (cases[expression] || defaultCase)() 用法： 12345678910111213141516let date = new Date()const today = switchCase&lt;number | Date&gt;({ cases: { year: () =&gt; date.getFullYear(), month: () =&gt; date.getMonth() + 1, day: () =&gt; date.getDate() }, defaultCase: () =&gt; date})today('year') // current yeartoday('month') // current monthtoday('day') // current daytoday('century') // default case - returns the current date Object 🌟更多精彩 点击👉这里~~","link":"/lmblog/2024/01/22/Javascriptswitch%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%B3%95/"}],"tags":[{"name":"pwa","slug":"pwa","link":"/lmblog/tags/pwa/"},{"name":"pwabuilder","slug":"pwabuilder","link":"/lmblog/tags/pwabuilder/"},{"name":"javascript","slug":"javascript","link":"/lmblog/tags/javascript/"},{"name":"webdev","slug":"webdev","link":"/lmblog/tags/webdev/"},{"name":"css","slug":"css","link":"/lmblog/tags/css/"},{"name":"初学者","slug":"初学者","link":"/lmblog/tags/%E5%88%9D%E5%AD%A6%E8%80%85/"},{"name":"前端","slug":"前端","link":"/lmblog/tags/%E5%89%8D%E7%AB%AF/"},{"name":"promises","slug":"promises","link":"/lmblog/tags/promises/"},{"name":"beginners","slug":"beginners","link":"/lmblog/tags/beginners/"},{"name":"designpatterns","slug":"designpatterns","link":"/lmblog/tags/designpatterns/"},{"name":"coding","slug":"coding","link":"/lmblog/tags/coding/"}],"categories":[{"name":"转载","slug":"转载","link":"/lmblog/categories/%E8%BD%AC%E8%BD%BD/"},{"name":"csdn","slug":"csdn","link":"/lmblog/categories/csdn/"}],"pages":[]}